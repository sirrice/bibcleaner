#!/usr/bin/env python3

import argparse
import sys
import flask
import os
import re
import time
import json
import pdb
import random
import traceback
from collections import *

import click
import biblib.bib
import sqlalchemy
from sqlalchemy import *
from sqlalchemy.pool import NullPool
from flask import Flask, request, render_template, g, redirect, Response

tmpl_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'templates')
app = Flask(__name__, template_folder=tmpl_dir)



# synonyms are reconciled to the dictionary key
# e.g., all journal and article entry keys are renamed into booktitle keys
synonyms = dict(
    booktitle=['journal', 'article']
)

# These constitute "real" article entries.  
# We normalize them all into @inproceedings entries
entry_types = set(['inproceedings', 'article', 'journal'])

# keys part of inproceedings/journal/article entries, skip all others
entry_keys = ['author', 'title', 'journal', 'booktitle', 'year', 'url']

# throw away all other entry keys, if you change this, make sure to change the entries schema in the 
# create table statement below.
allowed_keys = ['type', 'key', 'title', 'year', 'booktitle', 'author', 'howpublished', 'publisher', 'url']



# setup database

SETUPQS = ["""CREATE TABLE if not exists mapping (
  id serial,
  oldbook text,
  newbook text
);""",
"""CREATE TABLE if not exists entries (
  id serial,
  type text NOT NULL, -- book, misc, or inproceedings
  key text UNIQUE NOT NULL,  -- wu2015
  title text NOT NULL,
  year text,
  booktitle text, -- old book titel
  author text,
  howpublished text,
  publisher text,
  url text
)
"""
]

DATABASEURI = "sqlite:///bibcleaner.db"

engine = create_engine(DATABASEURI)
for q in SETUPQS:
  engine.execute(q)





def fix_synonyms(fields, synonyms):
  for key in synonyms:
    for syn in synonyms[key]:
      if syn in fields and fields[syn]:
        fields[key] = fields.get(syn)
        del fields[syn]
  return fields

def load_bibfile(bibfile, min_crossrefs=None):
  """
  Given bib file object, parse it and return the list of Entry objects
  Normalizes all inproceedings, article, and journal entry types to inproceedings type.
  """
  try:
    # Load databases
    db = biblib.bib.Parser(paranoid=False).parse(bibfile, log_fp=sys.stderr).get_entries()

    # Optionally resolve cross-references
    if min_crossrefs is not None:
      db = biblib.bib.resolve_crossrefs(
        db, min_crossrefs=min_crossrefs)
  except biblib.messages.InputError:
    #sys.exit(1)
    pass


  ents = []
  for ent in db.values():
    if not ent.key: continue
    if ent.typ in entry_types:
      keys = entry_keys
    else:
      ents.append(ent)
      continue

    vals = [" ".join(ent.get(key, '').split("\n")) for key in keys]
    # only keep keys that have non-null values
    fields = dict(filter(lambda p: p[1], zip(keys, vals)))
    fields = fix_synonyms(fields, synonyms)

    # change paper entries into @inproceedings
    newent = biblib.bib.Entry(fields.items())
    newent.typ = 'inproceedings'
    newent.key = ent.key
    ents.append(newent)

  return ents

def print_entries(printout, out, sort):
  """
  print entries to stdout, and optionally, if out is not None, write to file
  """

  q = """
  SELECT type, key, title, year, newbook as booktitle, author, howpublished, publisher, url
  FROM entries as E,
      (SELECT booktitle as oldbook, booktitle as newbook 
        FROM (SELECT distinct booktitle FROM entries) as foo 
        WHERE booktitle NOT IN (SELECT oldbook FROM mapping)
        UNION 
        select oldbook, newbook from mapping) as M
  WHERE E.booktitle = M.oldbook
  """

  if sort:
    if sort == 'booktitle':
      order = "ORDER BY newbook"
    else:
      order = "ORDER BY %s" % sort
    q += "\n" + order

  print(" ".join(q.split("\n")))


  # turn tuples into biblib.bib.Entry objects
  ents = []
  cur = engine.execute(q)
  keys = cur.keys()
  list(map(keys.remove, ['type', 'key']))
  for row in cur:
    d = dict([(key, str(row[key])) for key in keys if row[key]])
    ent = biblib.bib.Entry(d.items())
    ent.typ = row['type']
    ent.key = row['key']
    ents.append(ent)


  # print to standard out
  if printout:
    for ent in ents:
      print(ent.to_bib())

  # log to file
  if out:
    with open(out, 'w') as f:
      for ent in ents:
        f.write(ent.to_bib())
        f.write('\n')

def save_entries(entries):
  """
  insert entries into database
  """
  for e in entries:
    keys = set(e.keys()).intersection(allowed_keys)
    vals = list(map(e.get, keys))
    args = (
        ", ".join(keys),
        ", ".join(["?"] * len(vals))
    )
    q = "INSERT INTO entries(key, type, %s) VALUES(?, ?, %s)" % args
    try:
      engine.execute(q, tuple([e.key, e.typ] + vals))
    except sqlalchemy.exc.IntegrityError:
      continue
    except Exception as err:
      import pdb; pdb.set_trace()
      print(e)
      exit(1)






############################################
#
#  Server Code
#
############################################



@app.before_request
def before_request():
  try:
    g.conn = engine.connect()
  except:
    traceback.print_exc()
    g.conn = None

@app.teardown_request
def teardown_request(exception):
  try:
    if hasattr(g, 'conn'):
      g.conn.close()
  except Exception as e:
    print(e)
    pass

@app.route('/', methods=["POST", "GET"])
def index():
  cur = g.conn.execute("""
    SELECT booktitle, count(*) FROM entries WHERE booktitle NOT IN (SELECT oldbook FROM mapping UNION SELECT newbook FROM mapping) GROUP BY booktitle ORDER BY booktitle;""")
  books = [dict(name=row[0], count=row[1]) for row in cur]
  cur = g.conn.execute("SELECT oldbook, newbook, rowid FROM mapping")
  mapping = [dict(oldbook=row[0], newbook=row[1], id=row[2]) for row in cur]

  tmp = defaultdict(list)
  for d in mapping:
    tmp[d['newbook']].append(d)
  gmapping = []
  for item in tmp.items():
    gmapping.append(dict(newbook=item[0], oldbooks=item[1]))
  gmapping.sort(key=lambda d: d['newbook'])

  context = dict(books = books, mapping=mapping, gmapping=gmapping)
  return render_template("index.html", **context)


@app.route('/rm/', methods=['POST', 'GET'])
def rm_mapping():
  try:
    id = request.form['id']
    q = "DELETE FROM mapping WHERE rowid = ?"
    g.conn.execute(q, (id,))
    return json.dumps(dict(status="OK"))
  except Exception as ee:
    print(ee)
    return json.dumps(dict(status="ERR"))

@app.route('/set/', methods=['POST', 'GET'])
def new_mapping():
  try:
    print(request.form)

    old = request.form['oldbook']
    new = request.form['newbook']
    print((old, new))
    try:
      q = """INSERT INTO mapping(oldbook, newbook) VALUES(?, ?)"""
      cur = g.conn.execute(q, (old, new))
      rowid = cur.lastrowid
      if rowid is not None:
        return json.dumps(dict(status="OK", id=rowid))
    except Exception as e:
      return json.dumps(dict(status="ERR", msg=str(e)))
      print(e)
  except Exception as ee:
    print(ee)
    return json.dumps(dict(status="ERR"))

def run_server(HOST='localhost', PORT=8000, threaded=False, debug=True):
  print("Point your browser to: http://%s:%d" % (HOST, PORT))
  app.run(host=HOST, port=PORT, debug=debug, threaded=threaded)



if __name__ == "__main__":

  @click.command()
  @click.option('--bibname', default=None)
  @click.option('--min-crossrefs', type=int, 
                help='minimum number of cross-referencing entries'
                ' required to expand a crossref; if omitted, no'
                ' expansion occurs', default=None)
  @click.option('--cleanentries', is_flag=True, help='remove bibtex entries from database')
  @click.option('--cleanmappings', is_flag=True, help='remove booktitle mappings from database')
  @click.option('--server', is_flag=True, help='run webserver to deduplicate bibtex entries that have been loaded')
  @click.option('--printout', is_flag=True, help='print normalized bibtex database to stdout')
  @click.option('--out', help='filename to output normalized bibtex database', default=None)
  @click.option('--sort', type=click.Choice(['year', 'author', 'booktitle', 'key']), help='when printing or outputing cleaned bibtex, optional sort order')
  def main(bibname, min_crossrefs, cleanentries, cleanmappings, server, printout, out, sort):
    """
    Simple script to parse a bibtex file, store in database, keep only useful attributes,
    normalize all entries to @inproceedings, and runs a web gui to deduplicate booktitles.
    """
    if cleanentries:
      if input("Are you sure you want to clear the entries?\nType Y or yes to confirm: ").lower() in ['y', 'yes']:
        engine.execute("delete from entries")
    if cleanmappings:
      if input("Are you sure you want to clear the mappings?\nType Y or yes to confirm: ").lower() in ['y', 'yes']:
        engine.execute("delete from mapping")

    if bibname:
        with open(bibname) as bib:
            entries = load_bibfile(bib, min_crossrefs)
            save_entries(entries)
    if server:
      run_server()
    if out or printout:
      print_entries(printout, out, sort)
    if not cleanentries and not cleanmappings and not bibname and not server and not out and not printout:
      print("./bibcleaner --help")


  main()

